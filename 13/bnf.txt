== BNF
<top-decls> ::= ( <declaration> )*

<declaration> ::= <data-declaration> | <procedure> | <main-program>
### Not strictly true atm - will accept this, but will splatter data
### declarations in the wrong places in the ASM if after a procedure
### or whatever

<main-program> ::= PROGRAM <ident> [';'] <begin-block>
<begin-block> ::= BEGIN <block> END

<data-declaration> ::= VAR <var-list> [';']

<var-list> ::= <var> ( ',' <var> )*
<var> ::= <ident> [ = <integer> ]

<block> ::= ( <statement> )*

<assignment> ::= <ident> '=' <bool-expr> ';'

=== Procedures
<procedure> ::= PROCEDURE <ident> '(' <param-list> ')' [';'] <begin-block>
<proc-call> ::= <ident> '(' <param-list> ')'
<param-list> ::= <parameter> ( ',' <parameter> )* | null

=== Expressions
<bool-expr> ::= <bool-term> ( <orop> <bool-term> )*
<bool-term> ::= <not-factor> ( <andop> <not-factor> )*
<not-factor> ::= [ '!' ] <relation>
<relation> ::= <expression> [ <relop> <expression> ]

<expression> ::= <first term> ( <addop> <term> )*
<first term> ::= <first factor> <rest>
<term> ::= <factor> <rest>
<rest> ::= ( <mulop> <factor> )*
<first factor> ::= [ <addop> ] <factor>
<factor> ::= <var> | <number> | '(' <expression> ')'

=== Conditional Expressions
<if> ::= IF <bool-expression> <block> [ ELSE <block> END]
<while> ::= WHILE <bool-expression> <block> END
<statement> ::= <if> | <while> | <assignment> | <proc-call>

=== IO Operations
<read> :: READ '(' <var> [ ',' <var> ] ')'
<write> :: WRITE '(' <var> [ ',' <var> ] ')'
 
== Keywords
 PROGRAM
 PROCEDURE
 VAR
 BEGIN
 END
 IF
 ELSE
 WHILE
 READ
 WRITE

== Arithmetic Operators
 + - / *

== Boolean Operators
 | & !

== Relational Operators
 < > <> >= <= = 


