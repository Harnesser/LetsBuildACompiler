!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Abort	main.c	/^void Abort(const char *msg)$/;"	f
Add	arithmetic.c	/^void Add(void)$/;"	f
AddEntry	symboltable.c	/^void AddEntry(char *ident)$/;"	f
Alloc	assembly.c	/^void Alloc(char *name)$/;"	f
AsmEpilog	assembly.c	/^void AsmEpilog(void) { printf("%s\\n", asm_epilog); }$/;"	f
AsmHeader	assembly.c	/^void AsmHeader(void) { printf("%s\\n", asm_header); }$/;"	f
AsmProlog	assembly.c	/^void AsmProlog(void) { printf("%s\\n", asm_prolog); }$/;"	f
Assignment	arithmetic.c	/^void Assignment(void)$/;"	f
Block	main.c	/^void Block(void)$/;"	f
BoolExpression	boolean.c	/^void BoolExpression(void)$/;"	f
BoolOr	boolean.c	/^void BoolOr(void)$/;"	f
BoolTerm	boolean.c	/^void BoolTerm(void)$/;"	f
BoolXor	boolean.c	/^void BoolXor(void)$/;"	f
Branch	assembly.c	/^void Branch(char *label)$/;"	f
BranchFalse	assembly.c	/^void BranchFalse(char *label)$/;"	f
Clear	assembly.c	/^void Clear(void) { EmitLn("movl $0, %eax"); }$/;"	f
Decl	main.c	/^void Decl(void)$/;"	f
Divide	arithmetic.c	/^void Divide(void)$/;"	f
DoIf	conditional.c	/^void DoIf(void)$/;"	f
DoRead	io.c	/^void DoRead()$/;"	f
DoWhile	conditional.c	/^void DoWhile(void)$/;"	f
DoWrite	io.c	/^void DoWrite()$/;"	f
Emit	assembly.c	/^void Emit(const char *msg)$/;"	f
EmitLn	assembly.c	/^void EmitLn(const char *msg)$/;"	f
Equals	boolean.c	/^void Equals(void)$/;"	f
Error	main.c	/^void Error(const char *msg)$/;"	f
Expected	main.c	/^void Expected(const char *msg)$/;"	f
Expression	arithmetic.c	/^void Expression(void)$/;"	f
Factor	arithmetic.c	/^void Factor(void)$/;"	f
FirstFactor	arithmetic.c	/^void FirstFactor(void)$/;"	f
FirstTerm	arithmetic.c	/^void FirstTerm(void)$/;"	f
GetChar	main.c	/^void GetChar(void)$/;"	f
GetName	scanning.c	/^void GetName(char *name)$/;"	f
GetNum	scanning.c	/^void GetNum(void)$/;"	f
GetOp	scanning.c	/^void GetOp(char *opstr)$/;"	f
Greater	boolean.c	/^void Greater(void)$/;"	f
InTable	symboltable.c	/^int InTable(char *ident)$/;"	f
Init	main.c	/^void Init(void)$/;"	f
IsAddop	arithmetic.c	/^int IsAddop(char tok) {$/;"	f
IsAlNum	main.c	/^int IsAlNum(const char tok) { return isalnum(tok); }$/;"	f
IsAlpha	main.c	/^int IsAlpha(const char tok) { return isalpha(tok); }$/;"	f
IsDigit	main.c	/^int IsDigit(const char tok) { return isdigit(tok); }$/;"	f
IsOp	scanning.c	/^int IsOp(char c)$/;"	f
IsOrop	boolean.c	/^int IsOrop(char c)$/;"	f
IsRelop	boolean.c	/^int IsRelop(char c)$/;"	f
IsWhite	main.c	/^int IsWhite(const char tok) { return isspace(tok); }$/;"	f
Keywords	scanning.c	/^char *Keywords[] = {$/;"	v
Less	boolean.c	/^void Less(void)$/;"	f
LessOrEqual	boolean.c	/^void LessOrEqual(void)$/;"	f
LoadConst	assembly.c	/^void LoadConst(int val) {$/;"	f
LoadVar	assembly.c	/^void LoadVar(char *name) {$/;"	f
Look	main.c	/^char Look;  \/* lookahead character *\/$/;"	v
Lookup	scanning.c	/^int Lookup(char *token) $/;"	f
MAXENTRY	main.c	/^const int MAXENTRY = 100; \/* max # of symbols in the table *\/$/;"	v
MAXLBL	main.c	/^const int MAXLBL = 8+1;$/;"	v
MAXMSG	main.c	/^const int MAXMSG = 100;$/;"	v
MAXNAME	main.c	/^const int MAXNAME = 25+1;$/;"	v
MAXOPER	main.c	/^const int MAXOPER = 5;$/;"	v
Match	scanning.c	/^void Match(const char tok)$/;"	f
MatchString	scanning.c	/^void MatchString(char *str)$/;"	f
Multiply	arithmetic.c	/^void Multiply(void)$/;"	f
NUMKEYWORDS	scanning.c	24;"	d	file:
NegFactor	arithmetic.c	/^void NegFactor(void)$/;"	f
Negate	assembly.c	/^void Negate(void) { EmitLn("neg %eax"); }$/;"	f
NewLabel	conditional.c	/^void NewLabel(void){$/;"	f
Next	scanning.c	/^void Next(void)$/;"	f
NotEquals	boolean.c	/^void NotEquals(void)$/;"	f
NotFactor	boolean.c	/^void NotFactor(void)$/;"	f
NotIt	assembly.c	/^void NotIt(void) { EmitLn("notl %eax"); }$/;"	f
NumSymbols	symboltable.c	/^int NumSymbols = 0;$/;"	v
PopAdd	assembly.c	/^void PopAdd(void)$/;"	f
PopAnd	assembly.c	/^void PopAnd(void) {$/;"	f
PopCompare	assembly.c	/^void PopCompare(void) {$/;"	f
PopDiv	assembly.c	/^void PopDiv(void)$/;"	f
PopMul	assembly.c	/^void PopMul(void)$/;"	f
PopOr	assembly.c	/^void PopOr(void) {$/;"	f
PopSub	assembly.c	/^void PopSub(void)$/;"	f
PopXor	assembly.c	/^void PopXor(void) {$/;"	f
PostLabel	conditional.c	/^void PostLabel(char *label)$/;"	f
Printable	main.c	/^void Printable(char *pline, char tok)$/;"	f
Prog	main.c	/^void Prog(void)$/;"	f
Push	assembly.c	/^void Push(void) { EmitLn("pushl %eax"); }$/;"	f
ReadVar	assembly.c	/^void ReadVar(char *name)$/;"	f
Relation	boolean.c	/^void Relation(void)$/;"	f
Scan	scanning.c	/^void Scan(void) $/;"	f
SetEqual	assembly.c	/^void SetEqual(void) {$/;"	f
SetGreater	assembly.c	/^void SetGreater(void) {$/;"	f
SetGreaterOrEqual	assembly.c	/^void SetGreaterOrEqual(void) {$/;"	f
SetLess	assembly.c	/^void SetLess(void) {$/;"	f
SetLessOrEqual	assembly.c	/^void SetLessOrEqual(void) {$/;"	f
SetNEqual	assembly.c	/^void SetNEqual(void) {$/;"	f
ShowSymTable	symboltable.c	/^void ShowSymTable(void)$/;"	f
SkipWhite	main.c	/^void SkipWhite(void)$/;"	f
Store	assembly.c	/^void Store(char *name)$/;"	f
Sub	arithmetic.c	/^void Sub(void)$/;"	f
SymTable	symboltable.c	/^char SymTable[100][26];$/;"	v
T_BEGIN	main.c	/^               T_IF, T_ELSE, T_ENDIF, T_END, T_BEGIN, T_VAR, T_WHILE, T_ENDWHILE,$/;"	e	enum:__anon1	file:
T_ELSE	main.c	/^               T_IF, T_ELSE, T_ENDIF, T_END, T_BEGIN, T_VAR, T_WHILE, T_ENDWHILE,$/;"	e	enum:__anon1	file:
T_END	main.c	/^               T_IF, T_ELSE, T_ENDIF, T_END, T_BEGIN, T_VAR, T_WHILE, T_ENDWHILE,$/;"	e	enum:__anon1	file:
T_ENDIF	main.c	/^               T_IF, T_ELSE, T_ENDIF, T_END, T_BEGIN, T_VAR, T_WHILE, T_ENDWHILE,$/;"	e	enum:__anon1	file:
T_ENDWHILE	main.c	/^               T_IF, T_ELSE, T_ENDIF, T_END, T_BEGIN, T_VAR, T_WHILE, T_ENDWHILE,$/;"	e	enum:__anon1	file:
T_IDENT	main.c	/^               T_IDENT, T_NUMBER, T_OPER } e_token;$/;"	e	enum:__anon1	file:
T_IF	main.c	/^               T_IF, T_ELSE, T_ENDIF, T_END, T_BEGIN, T_VAR, T_WHILE, T_ENDWHILE,$/;"	e	enum:__anon1	file:
T_NUMBER	main.c	/^               T_IDENT, T_NUMBER, T_OPER } e_token;$/;"	e	enum:__anon1	file:
T_OPER	main.c	/^               T_IDENT, T_NUMBER, T_OPER } e_token;$/;"	e	enum:__anon1	file:
T_OTHER	main.c	/^typedef enum { T_OTHER=0,$/;"	e	enum:__anon1	file:
T_PROGRAM_END	main.c	/^               T_PROGRAM_END,$/;"	e	enum:__anon1	file:
T_READ	main.c	/^               T_READ, T_WRITE,	$/;"	e	enum:__anon1	file:
T_VAR	main.c	/^               T_IF, T_ELSE, T_ENDIF, T_END, T_BEGIN, T_VAR, T_WHILE, T_ENDWHILE,$/;"	e	enum:__anon1	file:
T_WHILE	main.c	/^               T_IF, T_ELSE, T_ENDIF, T_END, T_BEGIN, T_VAR, T_WHILE, T_ENDWHILE,$/;"	e	enum:__anon1	file:
T_WRITE	main.c	/^               T_READ, T_WRITE,	$/;"	e	enum:__anon1	file:
Term	arithmetic.c	/^void Term(void)$/;"	f
Term1	arithmetic.c	/^void Term1(void)$/;"	f
Token	main.c	/^char Token[26]; \/* scanned token *\/$/;"	v
TokenId	main.c	/^e_token TokenId;$/;"	v
TopDecls	main.c	/^void TopDecls(void)$/;"	f
Undefined	assembly.c	/^void Undefined(char *name)$/;"	f
Value	main.c	/^int Value; $/;"	v
WriteVar	assembly.c	/^void WriteVar()$/;"	f
asm_epilog	assembly.c	/^char asm_epilog[] = "\\$/;"	v
asm_header	assembly.c	/^char asm_header[] = "#PURPOSE:  KISS Program \\n\\$/;"	v
asm_prolog	assembly.c	/^char asm_prolog[] = "\\$/;"	v
clear_ident	scanning.c	/^void clear_ident(char *ident)$/;"	f
colno	main.c	/^int colno;$/;"	v
e_token	main.c	/^               T_IDENT, T_NUMBER, T_OPER } e_token;$/;"	t	typeref:enum:__anon1	file:
label	main.c	/^char label[9]; \/* label for machine code  conditionals *\/$/;"	v
labelno	main.c	/^int labelno;$/;"	v
lineno	main.c	/^int lineno;$/;"	v
main	main.c	/^int main(int argc, char *argv[])$/;"	f
message	main.c	10;"	d	file:
message	main.c	8;"	d	file:
pLook	main.c	/^char pLook[26]; \/* printable version of Look *\/$/;"	v
